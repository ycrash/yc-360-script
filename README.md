# yc-360 Script: One Script to Capture 360° Production Artifacts
[![License](https://img.shields.io/badge/license-Apache%202.0-orange.svg)](LICENSE)
[![Docs](https://img.shields.io/badge/yc--360%20Script-Documentation-green)](https://docs.ycrash.io/yc-360/launch-modes/only-capture-mode.html)

![img](/docs/images/360-degree.png)

## What is yc-360 Script?

**yc-360 script** is a simple script that captures 16 different artifacts from your application in a [pristine manner](https://docs.ycrash.io/yc-360/features/pristine-capture.html), which are highly useful to troubleshoot production problems. Here is the list of artifacts captured by the script:

| **Artifact**          | **What It Captures**                                                                 |
|-----------------------|--------------------------------------------------------------------------------------|
| Application Log       | Logs generated by your application—useful for identifying functional failures       |
| GC Log                | Garbage collection activity—helps detect memory overuse, frequent GCs, pauses       |
| Thread Dump           | Snapshot of all threads in the JVM—key to spotting deadlocks, BLOCKED/stuck threads |
| Heap Dump             | Memory snapshot of JVM objects—used to identify memory leaks or heavy objects       |
| Heap Substitute       | Lightweight version of heap dump when full heap dump isn’t available                |
| `top`                 | Overall CPU/memory usage of system processes                                         |
| `ps`                  | Snapshot of currently running processes                                              |
| `top -H`              | Thread-level CPU usage—helps isolate CPU-intensive threads                           |
| Disk Usage (`df -h`)  | Available/used disk space—useful when app errors stem from full disks                |
| `dmesg`               | Kernel logs—catches low-level system issues like hardware errors or OOM kills        |
| `netstat`             | Network connections, open ports, and listening sockets                               |
| `ping`                | Network latency to external or internal endpoints                                    |
| `vmstat`              | Virtual memory, I/O, and CPU scheduling stats                                        |
| `iostat`              | Disk I/O performance metrics                                                         |
| Kernel Parameters     | System tuning configurations (like swappiness, max open files)                       |
| Extended Data         | Any custom scripts or data you configure yc-360 script to collect                           |
| Metadata              | Basic system/app metadata (JVM version, hostname, uptime, etc.)                      |


## Why you need yc-360 Script?

**1. Capture Deeper 360° Artifacts for Root Cause Analysis:** Monitoring tools like APMs are excellent at reporting problems such as memory spikes, high CPU usage, or degraded response times. However, when it's time to get to the root cause, you need more than charts and alerts. For example, if memory consumption spikes, you will need a heap dump to identify which objects are leaking. If CPU usage increases, a thread dump is required to trace it back to the exact lines of code causing the spike. The yc-360 script complements your APM by collecting these deeper diagnostic artifacts in a single run—making it much easier and faster to isolate the problem.

**2. Accelerate Troubleshooting in Customer On-Prem Environments:** In many cases, our application runs on a customer’s infrastructure where we don’t have shell access or real-time visibility. Asking them to send screenshots or partial logs [rarely provides enough context to troubleshoot effectively](https://blog.ycrash.io/key-challenges-in-troubleshooting-applications-at-customer-premise/). The yc-360 script solves this by giving you a simple script that the customer can run themselves. It gathers all the essential artifacts across Application, JVM, system, and network layers - so you get everything you need to troubleshoot the issue thoroughly, even without direct access.

**3. Forecast Production Incidents During Pre-Release Testing:** Before every release, we run performance tests to validate CPU, memory, and response times. But these Macro-Metrics alone don’t reveal deeper risks. yc-360 script enables you to analyze Micro-Metrics like GC throughput, object allocation rate, socket usage, and thread pool behaviors. These overlooked Micro-metrics, signals early signs of instability, giving you a chance to [identify the performance issues before they hit production](https://blog.ycrash.io/micro-metrics-every-performance-engineer-should-validate-before-sign-off/).

## Getting Started - How to run the yc-360 Script?

It's easy to get started with the yc-360 script. Just follow the simple steps given below. In a matter of seconds, you’ll be able to trigger the script and collect all the critical artifacts needed for troubleshooting.

<details>
	<summary><strong>Linux</storng></summary></br>
	
<strong>1. Download:</strong> Download the latest version of the yc-360 script from [here](https://tier1app.com/dist/ycrash/yc-360-latest.zip)

<storng>2. Extract:</storng> Unzip the package and navigate to the linux directory:

```sh
unzip yc-360-latest.zip
cd linux
```

<storng>3. Execute yc-360 Script:</storng> Run the script with your target application's process ID:

When you execute the below command, the yc-360 script will capture all the artifacts/logs from the target JVM & host for analysis. Captured artifacts will be compressed into a zip file and stored in the directory where the above command was executed. The zip file will have the name in the format: 'yc-YYYY-MM-DDTHH-mm-ss.zip'. **Example**: 'yc-2024-09-23T14-02-42.zip'.

```sh
./yc -onlyCapture -p {PID} -j {JAVA_HOME} -a {APPLICATION_NAME}
```

<storng>INFO:</storng>

+ `{PID}`: This is the process ID of your Java application. Not sure how to find process Id? [Learn here](https://docs.ycrash.io/yc-360/faq/identifying-process.html). Alternatively, you can pass Unique Token that will uniquely identify the process in container. [What is Unique Token?](https://docs.ycrash.io/yc-360/faq/what-is-unique-token-in-process.html)

+ `{JAVA_HOME}`: The directory path where Java is installed in your environment.

+ `{APPLICATION_NAME}`: Friendly name for the application (displayed in the yCrash dashboard).

<storng>IMPORTANT TIP:<storng>

+ The yc-360 script must be executed with the **same user privileges as the Java application**. For example, if the application runs under the `tomcat-user` user, yc-360 script must also be executed by `tomcat-user` user.

+ To detect memory-related issues, **GC logging** must be enabled for your application. You can enable GC logging by using the JVM arguments listed [here](https://docs.ycrash.io/yc-360/faq/how-to-enable-gc-logs.html).

+ The yc-360 script doesn't capture heap dump by default. Pass `-hd` argument to capture heap dump. For more information, please visit [How to Capture Heap Dump?](https://docs.ycrash.io/yc-360/faq/how-to-capture-heapdump.html)

</details>
<details>
	<summary><strong>MacOS</storng></summary></br>
	
<storng>1. Download:</storng> Download the latest version of the yc-360 script from [here](https://tier1app.com/dist/ycrash/yc-360-latest.zip).

<storng>2. Extract:</storng> Unzip the package and navigate to the mac directory:

```sh
unzip yc-360-latest.zip
cd mac
```

<storng>3. Execute yc-360 Script:</storng> Run the script with your target application's process ID:

When you execute the below command, the yc-360 script will capture all the artifacts/logs from the target JVM & host for analysis. Captured artifacts will be compressed into a zip file and stored in the directory where the above command was executed. The zip file will have the name in the format: 'yc-YYYY-MM-DDTHH-mm-ss.zip'. **Example**: 'yc-2024-09-23T14-02-42.zip'.

```sh
./yc -onlyCapture -p {PID} -j {JAVA_HOME} -a {APPLICATION_NAME}
```

<storng>INFO:</storng>

+ `{PID}`: This is the process ID of your Java application. Not sure how to find process Id? [Learn here](https://docs.ycrash.io/yc-360/faq/identifying-process.html). Alternatively, you can pass Unique Token that will uniquely identify the process in container. [What is Unique Token?](https://docs.ycrash.io/yc-360/faq/what-is-unique-token-in-process.html)

+ `{JAVA_HOME}`: The directory path where Java is installed in your environment.

+ `{APPLICATION_NAME}`: Friendly name for the application (displayed in the yCrash dashboard).

<storng>IMPORTANT TIP:</storng>

+ The yc-360 script must be executed with the **same user privileges as the Java application**. For example, if the application runs under the `tomcat-user` user, yc-360 script must also be executed by `tomcat-user` user.

+ To detect memory-related issues, **GC logging** must be enabled for your application. You can enable GC logging by using the JVM arguments listed [here](https://docs.ycrash.io/yc-360/faq/how-to-enable-gc-logs.html).

+ The yc-360 script doesn't capture heap dump by default. Pass `-hd` argument to capture heap dump. For more information, please visit [How to Capture Heap Dump?](https://docs.ycrash.io/yc-360/faq/how-to-capture-heapdump.html)

</details>

<details>
	<summary><strong>Windows</storng></summary></br>
	
<storng>1. Download:</storng> Download the latest version of the yc-360 script from [here](https://tier1app.com/dist/ycrash/yc-360-latest.zip).

<storng>2. Extract:</storng> Unzip the package and navigate to the windows directory:

```
cd windows
```

<storng>3. Execute yc-360 Script:</storng> Run the script with your target application's process ID:

When you execute the below command, the yc-360 script will capture all the artifacts/logs from the target JVM & host for analysis. Captured artifacts will be compressed into a zip file and stored in the directory where the above command was executed. The zip file will have the name in the format: 'yc-YYYY-MM-DDTHH-mm-ss.zip'. **Example**: 'yc-2024-09-23T14-02-42.zip'.

```sh
.\yc -onlyCapture -p {PID} -j {JAVA_HOME} -a {APPLICATION_NAME}
```

<storng>INFO:</storng>

+ `{PID}`: This is the process ID of your Java application. Not sure how to find process Id? [Learn here](https://docs.ycrash.io/yc-360/faq/identifying-process.html). Alternatively, you can pass Unique Token that will uniquely identify the process in container. [What is Unique Token?](https://docs.ycrash.io/yc-360/faq/what-is-unique-token-in-process.html)

+ `{JAVA_HOME}`: The directory path where Java is installed in your environment.

+ `{APPLICATION_NAME}`: Friendly name for the application (displayed in the yCrash dashboard).

<storng>IMPORTANT TIP:</storng>

+ The yc-360 script must be executed with the **same user privileges as the Java application**. For example, if the application runs under the `tomcat-user` user, yc-360 script must also be executed by `tomcat-user` user.

+ To detect memory-related issues, **GC logging** must be enabled for your application. You can enable GC logging by using the JVM arguments listed [here](https://docs.ycrash.io/yc-360/faq/how-to-enable-gc-logs.html).

+ The yc-360 script doesn't capture heap dump by default. Pass `-hd` argument to capture heap dump. For more information, please visit [How to Capture Heap Dump?](https://docs.ycrash.io/yc-360/faq/how-to-capture-heapdump.html)
</details>

<details>
	<summary><strong>Docker</storng></summary></br>

You can run the yc-360 script in a Docker environment using one of the following approaches, depending on your deployment setup and monitoring preferences:

1. [Run yc-360 Script in Sidecar Container](https://docs.ycrash.io/yc-360/docker-container/deployment-options/run-yc-360-script-as-sidecar-container.html) – Run the script in a separate container alongside your application container.

2. [Run yc-360 Script in Same Container](https://docs.ycrash.io/yc-360/docker-container/deployment-options/run-yc-360-script-in-same-container.html) – Embed the yc-360 script directly inside the application container.

3. [Run yc-360 Script on Host](https://docs.ycrash.io/yc-360/docker-container/deployment-options/run-yc-360-script-on-host.html) – Run the script on the host that is running your Docker containers.
</details>

<details>
	<summary><strong>Kubernetes</storng></summary></br>
	
You can run the yc-360 script in a Kubernetes environment using one of the following approaches, depending on your deployment setup and monitoring preferences:

1. [Run yc-360 Script in Sidecar Container](https://docs.ycrash.io/yc-360/kubernetes/deployment-options/run-as-sidecar-container.html) – Add yc-360 as a separate container in your pod spec.

2. [Run yc-360 Script in Same Container](https://docs.ycrash.io/yc-360/kubernetes/deployment-options/run-in-same-container.html) – Install and run the script directly inside your application container.
</details>

<details>

	<summary><strong>OpenShift</storng></summary></br>
	
To monitor applications running in OpenShift, deploy the yc-360 script using:

[Run yc-360 Script in Sidecar Container](https://docs.ycrash.io/yc-360/openshift/deployment-options/run-as-sidecar-container.html)– Add yc-360 alongside your application within the pod template.
</details>


## How to Analyze the Artifacts Generated by the yc-360-script?

You can analyze the artifacts captured by yc-360-script either manually or through [yCrash server](https://ycrash.io/). yCrash server analyzes all the captured data and generates a root cause analysis report instantly. You can use the [Bundle upload](https://docs.ycrash.io/ycrash-features/bundle-upload.html#step-1-go-to-upload-incident-form) feature in the yCrash server to analyze the captured 360-degree data. 

## FAQ

<details>
  <summary><strong>1. What if I Want to Capture Additional Data that yc-360 Script Doesn’t Collect by Default?</strong></summary></br>
  
You can extend the functionality using the [`-edScript` argument](https://docs.ycrash.io/yc-360/features/extended-data.html). This lets you specify a custom script that yc-360 script will execute as the final step, allowing you to capture additional logs, metrics, or custom files specific to your environment.
</details>

<details>
  <summary><strong>2. What is the Overhead of Running yc-360 Script?</strong></summary></br>

The yc-360 script is designed to be lightweight and non-intrusive, ensuring minimal impact on your application's performance. It primarily reads existing system and application data without altering configurations or consuming significant resources. In performance tests conducted on a Linux machine running a Java Spring Boot application, the script demonstrated:

- **CPU Usage:** Averaging around 0.05%, with occasional spikes up to 3% during data collection.
- **Memory Usage:** Consistently between 0.1% and 0.2%.

These metrics indicate that yc-360 script can safely run in production environments without causing noticeable overhead. For detailed insights, refer to the [yc-360 Script Overhead Performance](https://blog.ycrash.io/ycrash-agent-overhead-performance/) blog post.
</details>

<details>
  <summary><strong>3. Is it Safe to Run yc-360 Script in Production Environments?</strong></summary></br>

Absolutely. The yc-360 script is a non-intrusive, script. It doesn’t modify any application or system configuration. It only reads and collects diagnostics and is safe to run even in high-availability production environments.
</details>

<details>
  <summary><strong>4. Can yc-360 Script be executed in containerized environments like Docker, Kubernetes, or OpenShift?</strong></summary></br>

Yes, yc-360 script is designed to work seamlessly across all major environments — including bare-metal servers, virtual machines, Docker containers, Kubernetes, and OpenShift. You can execute the script directly inside your containers or use it as part of a sidecar or init container to collect diagnostic data. For detailed guidance on each supported environments, visit [https://docs.ycrash.io/yc-360/environment/introduction.html](https://docs.ycrash.io/yc-360/environment/introduction.html)
</details>

<details>
  <summary><strong>5. What if I don’t have Direct Access to the Production Environment?</strong></summary></br>

That’s exactly what yc-360 script is built for. You can send the script to your customer or operations team and ask them to run it on your behalf. It generates a ZIP file with all the artifacts, which they can send back to you for analysis.
</details>

<details>
  <summary><strong>6. How Much Time Does it Take to Run?</strong></summary></br>

In most environments, yc-360 script completes execution in under 30 seconds. However, collecting heap dumps may take longer depending on the heap size and system performance.
</details>

<details>
  <summary><strong>7. What Kind of Issues Can yc-360 Script Help Troubleshoot?</strong></summary></br>

The yc-360 script is effective in diagnosing memory leaks, GC pauses, CPU spikes, thread contention, application freezes, disk pressure, network latency, backend slowness, and more. It provides a 360° snapshot of your application and environment at the time of the issue.
</details>

<details>
  <summary><strong>8. Where can I analyze the artifacts generated by the yc-360 script?</strong></summary></br>

You have two options:

- **Manual Analysis**: You can analyze individual artifacts using specialized tools like [gceasy.io](https://gceasy.io) for GC logs, [fastThread.io](https://fastthread.io) for thread dumps, [heaphero.io](https://heaphero.io) for heap dumps, or Eclipse MAT.

- **Automated Unified Analysis**: You can upload the entire artifact bundle to yCrash.io using the Bundle Upload feature for a comprehensive 360° root cause analysis.
For more details, refer to the [Bundle Upload](https://docs.ycrash.io/ycrash-features/bundle-upload.html) documentation.
</details>

<details>
  <summary><strong>9. How do I Schedule yc-360 Script to Run Periodically?</strong></summary></br>

You can schedule the script using cron (Linux/macOS), Task Scheduler (Windows), or Kubernetes CronJobs (in container environments). Just ensure the appropriate execution permission is set for the yc-360 script and Read/Write permissions for the output directory.
</details>

<details>
  <summary><strong>10. Is yc-360 Script Customizable?</strong></summary></br>

Yes. The yc-360 script is designed as a modular shell script. You can clone the repository and customize individual collection commands or add/remove specific artifacts based on your organization’s requirements.
</details>

<details>
  <summary><strong>11. Is Support Available for yc-360 Script?</strong></summary></br>

For community support, please use the [GitHub Issues page](https://github.com/ycrash/yc-data-script/issues). For enterprise-grade support and integration assistance, visit [yCrash.io](https://ycrash.io/).
</details>

<details>
  <summary><strong>12. How to Build the yc-360-script?</strong></summary></br>

Please refer to any one of the following links if you want to build the yc-360-script in that corresponding operating system:

1. Build yc-360-script in [Windows](/docs/build/build_yc_360_script_windows.md)
2. Build yc-360-script in [Linux](/docs/build/build_yc_360_script_linux.md)
3. Build yc-360-script in [MacOS](/docs/build/build_yc_360_script_macos.md)
</details>
